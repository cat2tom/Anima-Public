<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ANIMA: animaHierarchicalInitializer.hxx Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ANIMA
   &#160;<span id="projectnumber">2.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">animaHierarchicalInitializer.hxx</div>  </div>
</div><!--header-->
<div class="contents">
<a href="animaHierarchicalInitializer_8hxx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &quot;<a class="code" href="animaHierarchicalInitializer_8h.html">animaHierarchicalInitializer.h</a>&quot;</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="keyword">namespace </span>anima
<a name="l00004"></a>00004 {
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00007"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a79d118d591bd3b54b14fa1a38bcea6e9">00007</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a79d118d591bd3b54b14fa1a38bcea6e9">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetMask</a>(<span class="keyword">const</span> TMaskImage* mask)
<a name="l00008"></a>00008 {
<a name="l00009"></a>00009     this-&gt;SetNthInput(0, const_cast&lt;TMaskImage*&gt;(mask));
<a name="l00010"></a>00010 }
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00013"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#ad265dc67af7747e9f10ad0e5b95d31cb">00013</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#ad265dc67af7747e9f10ad0e5b95d31cb">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetInputImage1</a>(<span class="keyword">const</span> TInputImage* image)
<a name="l00014"></a>00014 {
<a name="l00015"></a>00015     this-&gt;SetNthInput(m_NbInputs, const_cast&lt;TInputImage*&gt;(image));
<a name="l00016"></a>00016     m_IndexImage1 = m_NbInputs;
<a name="l00017"></a>00017     m_NbInputs++;
<a name="l00018"></a>00018 }
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00021"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#aa3fcd9dc6a2776d6f6c557c4a4110b15">00021</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#aa3fcd9dc6a2776d6f6c557c4a4110b15">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetInputImage2</a>(<span class="keyword">const</span> TInputImage* image)
<a name="l00022"></a>00022 {
<a name="l00023"></a>00023     this-&gt;SetNthInput(m_NbInputs, const_cast&lt;TInputImage*&gt;(image));
<a name="l00024"></a>00024     m_IndexImage2 = m_NbInputs;
<a name="l00025"></a>00025     m_NbInputs++;
<a name="l00026"></a>00026 }
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00029"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a7c9b3a32c60a3638a5c4f172e042d03b">00029</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7c9b3a32c60a3638a5c4f172e042d03b">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetInputImage3</a>(<span class="keyword">const</span> TInputImage* image)
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031     this-&gt;SetNthInput(m_NbInputs, const_cast&lt;TInputImage*&gt;(image));
<a name="l00032"></a>00032     m_IndexImage3 = m_NbInputs;
<a name="l00033"></a>00033     m_NbInputs++;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00036"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#aca0d1df3b07621805d840e9ab49c2e5f">00036</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#aca0d1df3b07621805d840e9ab49c2e5f">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetInputImage4</a>(<span class="keyword">const</span> TInputImage* image)
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038     this-&gt;SetNthInput(m_NbInputs, const_cast&lt;TInputImage*&gt;(image));
<a name="l00039"></a>00039     m_IndexImage4 = m_NbInputs;
<a name="l00040"></a>00040     m_NbInputs++;
<a name="l00041"></a>00041 }
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00044"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a3ae70369f2b7efd1ea4e6b168188ad3e">00044</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a3ae70369f2b7efd1ea4e6b168188ad3e">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::SetInputImage5</a>(<span class="keyword">const</span> TInputImage* image)
<a name="l00045"></a>00045 {
<a name="l00046"></a>00046     this-&gt;SetNthInput(m_NbInputs, const_cast&lt;TInputImage*&gt;(image));
<a name="l00047"></a>00047     m_IndexImage5 = m_NbInputs;
<a name="l00048"></a>00048     m_NbInputs++;
<a name="l00049"></a>00049 }
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00053"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a1fbca58f5304fa1f7245f7f006e69207">00053</a> <span class="keyword">typename</span> TMaskImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#a1fbca58f5304fa1f7245f7f006e69207">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetMask</a>()
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TMaskImage * <span class="keyword">&gt;</span>
<a name="l00056"></a>00056             ( this-&gt;itk::ProcessObject::GetInput(0) );
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00060"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a51370487e44fb9f66da8e8aec351a5ea">00060</a> <span class="keyword">typename</span> TInputImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#a51370487e44fb9f66da8e8aec351a5ea">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetInputImage1</a>()
<a name="l00061"></a>00061 {
<a name="l00062"></a>00062     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TInputImage * <span class="keyword">&gt;</span>
<a name="l00063"></a>00063             ( this-&gt;itk::ProcessObject::GetInput(m_IndexImage1) );
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00067"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a8c2e1264fe0db5d6c6a78999072218">00067</a> <span class="keyword">typename</span> TInputImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a8c2e1264fe0db5d6c6a78999072218">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetInputImage2</a>()
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TInputImage * <span class="keyword">&gt;</span>
<a name="l00070"></a>00070             ( this-&gt;itk::ProcessObject::GetInput(m_IndexImage2) );
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00074"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a9e13f7d96308b34b57eabc8ca2464040">00074</a> <span class="keyword">typename</span> TInputImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#a9e13f7d96308b34b57eabc8ca2464040">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetInputImage3</a>()
<a name="l00075"></a>00075 {
<a name="l00076"></a>00076     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TInputImage * <span class="keyword">&gt;</span>
<a name="l00077"></a>00077             ( this-&gt;itk::ProcessObject::GetInput(m_IndexImage3) );
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00081"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#af1a262be454a7e092555f6ae0b627f3e">00081</a> <span class="keyword">typename</span> TInputImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#af1a262be454a7e092555f6ae0b627f3e">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetInputImage4</a>()
<a name="l00082"></a>00082 {
<a name="l00083"></a>00083     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TInputImage * <span class="keyword">&gt;</span>
<a name="l00084"></a>00084             ( this-&gt;itk::ProcessObject::GetInput(m_IndexImage4) );
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00088"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#afdb31de79b0e79162217a705312054c6">00088</a> <span class="keyword">typename</span> TInputImage::ConstPointer <a class="code" href="classanima_1_1HierarchicalInitializer.html#afdb31de79b0e79162217a705312054c6">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::GetInputImage5</a>()
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span> <span class="keyword">const </span>TInputImage * <span class="keyword">&gt;</span>
<a name="l00091"></a>00091             ( this-&gt;itk::ProcessObject::GetInput(m_IndexImage5) );
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00095"></a>00095 <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#ae79abd1ee489c92b11ae11ded077de25">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00096"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#ae79abd1ee489c92b11ae11ded077de25">00096</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#ae79abd1ee489c92b11ae11ded077de25">::ComputeSolution1D</a>()
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098     <span class="comment">// Compute EM for T1-w</span>
<a name="l00099"></a>00099     std::vector&lt;double&gt; min1D( 1, 255.0 ); <span class="comment">//min values for random Initialization</span>
<a name="l00100"></a>00100     std::vector&lt;double&gt; max1D( 1, 0.0 ); <span class="comment">//max values for random Initialization</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102     <span class="comment">// Decide initializer</span>
<a name="l00103"></a>00103     <a class="code" href="classanima_1_1RandomInitializer.html#acc1b59d509045cea6b45907f97b41577">RandomInitializer::Pointer</a> initiaRandom = <a class="code" href="classanima_1_1RandomInitializer.html#a5c11f91fc75ad3e2039633125d922b68">RandomInitializer::New</a>();
<a name="l00104"></a>00104     initiaRandom-&gt;SetMinValues( min1D );
<a name="l00105"></a>00105     initiaRandom-&gt;SetMaxValues( max1D );
<a name="l00106"></a>00106     initiaRandom-&gt;SetDimensionGaussian(1);
<a name="l00107"></a>00107     initiaRandom-&gt;SetNbGaussian(3);
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keyword">typename</span> <a class="code" href="classanima_1_1GaussianREMEstimator.html#af6c71850530e3216ef332824977053c7">GaussianREMEstimatorType::Pointer</a> estimator= GaussianREMEstimatorType::New();
<a name="l00110"></a>00110     estimator -&gt;SetMaxIterations( 100 );
<a name="l00111"></a>00111     estimator -&gt;SetModelMinDistance( 1e-3 );
<a name="l00112"></a>00112     estimator -&gt;SetMaxIterationsConc( 10 );
<a name="l00113"></a>00113     estimator -&gt;SetStremMode( <span class="keyword">false</span> );
<a name="l00114"></a>00114     estimator -&gt;SetRejectionRatio( m_Robust );
<a name="l00115"></a>00115     estimator -&gt;SetMask( this-&gt;GetMask() );
<a name="l00116"></a>00116     estimator -&gt;SetInputImage1( this-&gt;GetInputImage1() );
<a name="l00117"></a>00117     estimator -&gt;SetVerbose( <span class="keyword">false</span> );
<a name="l00118"></a>00118 
<a name="l00119"></a>00119     std::vector&lt;unsigned int&gt; emSteps( 1, 60 );
<a name="l00120"></a>00120     std::vector&lt;unsigned int&gt; iterSteps( 1, 60 );
<a name="l00121"></a>00121 
<a name="l00122"></a>00122     <span class="keyword">typename</span> <a class="code" href="classanima_1_1ClassificationStrategy.html#a6c4fe766475cd6e4f5f3a52fe5d99ab0">ClassificationStrategyType::Pointer</a> strategy = ClassificationStrategyType::New();
<a name="l00123"></a>00123     strategy-&gt;SetEstimator( estimator );
<a name="l00124"></a>00124     strategy-&gt;SetInitializer( initiaRandom );
<a name="l00125"></a>00125     strategy-&gt;SetStrategy( emSteps, iterSteps );
<a name="l00126"></a>00126     itk::CStyleCommand::Pointer callback = itk::CStyleCommand::New();
<a name="l00127"></a>00127     callback -&gt;SetCallback(<a class="code" href="animaDTIEstimator_8cxx.html#a7a999abe8cc847c5e232d0b10bf361e2">eventCallback</a>);
<a name="l00128"></a>00128     strategy -&gt;AddObserver(itk::ProgressEvent(), callback );
<a name="l00129"></a>00129     strategy-&gt;Update();
<a name="l00130"></a>00130     std::cout &lt;&lt; std::endl;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a231a9cf18fa936830e80d0bdef22ea0e">ModelMap</a> solutionClassifier;
<a name="l00133"></a>00133     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a5d4726d8835cabe6bfb83f1320a5b175">ModelMap2</a> solutionClassifierAlpha;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135     <span class="keywordflow">if</span> ( !strategy-&gt;GetSolutionMap( solutionClassifier, solutionClassifierAlpha ) )
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137         std::cerr &lt;&lt; <span class="stringliteral">&quot;-- Error: No solution found in first modality&quot;</span> &lt;&lt; std::endl;
<a name="l00138"></a>00138         <span class="keywordflow">return</span>;
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     m_Solution1D = solutionClassifier.begin() -&gt;second;
<a name="l00142"></a>00142     m_Solution1DAlphas = solutionClassifierAlpha.begin() -&gt;second;
<a name="l00143"></a>00143 }
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00146"></a>00146 <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#ae78f7129aec83ed014619f1705c13b49">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00147"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#ae78f7129aec83ed014619f1705c13b49">00147</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#ae78f7129aec83ed014619f1705c13b49">::ComputeInitialT1Classification</a>( )
<a name="l00148"></a>00148 {
<a name="l00149"></a>00149     <span class="comment">// Classify T1-w</span>
<a name="l00150"></a>00150     <span class="keyword">typename</span> <a class="code" href="classanima_1_1ImageClassifierFilter.html#a51c8b6588a1ae8138a1f82f0edff5abd">ImageClassifierType::Pointer</a> classifier = ImageClassifierType::New();
<a name="l00151"></a>00151     classifier-&gt;SetInputImage1(this-&gt;GetInputImage1());
<a name="l00152"></a>00152     classifier-&gt;SetMask(this-&gt;GetMask());
<a name="l00153"></a>00153     classifier-&gt;SetGaussianModel(m_Solution1D);
<a name="l00154"></a>00154     classifier-&gt;SetAlphas(m_Solution1DAlphas);
<a name="l00155"></a>00155     classifier-&gt;SetTol(m_Tol);
<a name="l00156"></a>00156     classifier-&gt;Update();
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="comment">// creating one image per class (CSF, GM, WM)</span>
<a name="l00159"></a>00159     std::vector&lt;InputIteratorType&gt; classesIt;
<a name="l00160"></a>00160     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 3; i++)
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162         <a class="code" href="classanima_1_1HierarchicalInitializer.html#a04489ffbfcbd1e70819a8a0be23e6348">InputImagePointer</a> im = InputImageType::New();
<a name="l00163"></a>00163         im-&gt;SetRegions(this-&gt;GetMask()-&gt;GetLargestPossibleRegion());
<a name="l00164"></a>00164         im-&gt;CopyInformation(this-&gt;GetMask());
<a name="l00165"></a>00165         im-&gt;Allocate();
<a name="l00166"></a>00166         im-&gt;FillBuffer(0);
<a name="l00167"></a>00167         m_ImagesClasses.push_back(im);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169         <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a896bb30424b38c542273f56d66cc49">InputIteratorType</a> imIt(im, im-&gt;GetLargestPossibleRegion() );
<a name="l00170"></a>00170         classesIt.push_back(imIt);
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7cf88b6fbad12599eabf476b7a40512d">InputConstIteratorType</a> classifIt(classifier-&gt;GetOutput(), classifier-&gt;GetOutput()-&gt;GetLargestPossibleRegion() );
<a name="l00174"></a>00174     <span class="keywordflow">while</span>(!classifIt.IsAtEnd())
<a name="l00175"></a>00175     {
<a name="l00176"></a>00176         <span class="keywordflow">if</span>(!(classifIt.Get() == 0 || classifIt.Get() &gt; 3 ))
<a name="l00177"></a>00177         {
<a name="l00178"></a>00178             classesIt[ classifIt.Get() - 1 ].Set(1);
<a name="l00179"></a>00179         }
<a name="l00180"></a>00180         ++classifIt;
<a name="l00181"></a>00181         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; classesIt.size(); i++)
<a name="l00182"></a>00182         {
<a name="l00183"></a>00183             ++classesIt[i];
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00189"></a>00189 <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#af7efb0b5d174dc6078886982280674b3">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00190"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#af7efb0b5d174dc6078886982280674b3">00190</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#af7efb0b5d174dc6078886982280674b3">::ComputeHistogram</a>( )
<a name="l00191"></a>00191 {
<a name="l00192"></a>00192     <span class="keyword">const</span> <span class="keywordtype">double</span> resolution = 1;
<a name="l00193"></a>00193     <span class="keyword">const</span> <span class="keywordtype">double</span> bandwidth = 5;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195     <span class="comment">// selection rules [sequence][class]</span>
<a name="l00196"></a>00196     <span class="comment">// +1 brighter max</span>
<a name="l00197"></a>00197     <span class="comment">// 0 absolute max</span>
<a name="l00198"></a>00198     <span class="comment">// -1 darker max</span>
<a name="l00199"></a>00199     std::vector&lt; std::vector&lt;int&gt; &gt; selectionRules( 3, std::vector&lt;int&gt;( 3, 0 ) );
<a name="l00200"></a>00200     selectionRules[ 1 ][ 0 ] = 1; <span class="comment">// T2-w &amp; CSF: brighter max</span>
<a name="l00201"></a>00201     <span class="keywordflow">if</span>(m_ThirdIsFLAIR)
<a name="l00202"></a>00202         selectionRules[ 2 ][ 0 ] = -1; <span class="comment">// FLAIR &amp; CSF: darker max</span>
<a name="l00203"></a>00203     <span class="keywordflow">else</span>
<a name="l00204"></a>00204         selectionRules[ 2 ][ 0 ] = 1; <span class="comment">// PD-w &amp; CSF: brighter max</span>
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     m_SelectedMax.resize( 3, std::vector&lt;double&gt;( 3, 0.0 ) );
<a name="l00207"></a>00207     m_Stds.resize(3, std::vector&lt;double&gt;( 3, 0.0 ));
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="keyword">typedef</span> <span class="keywordtype">double</span> MeasurementType;
<a name="l00210"></a>00210     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> MeasurementVectorLength = 1;
<a name="l00211"></a>00211     <span class="keyword">typedef</span> itk::Vector&lt; MeasurementType , MeasurementVectorLength &gt; <a class="code" href="classanima_1_1ModelInitializer.html#ab66fd2c1d09e10ba09fb38cc9e0b61e9">MeasurementVectorType</a>;
<a name="l00212"></a>00212     <span class="keyword">typedef</span> itk::Statistics::ListSample&lt; MeasurementVectorType &gt; ListSampleType;
<a name="l00213"></a>00213     <span class="keyword">typedef</span> itk::Statistics::DenseFrequencyContainer2 FrequencyContainerType;
<a name="l00214"></a>00214     <span class="keyword">typedef</span> itk::Statistics::Histogram&lt; MeasurementType,FrequencyContainerType &gt; HistogramType;
<a name="l00215"></a>00215     <span class="keyword">typedef</span> itk::Statistics::SampleToHistogramFilter&lt;ListSampleType,HistogramType&gt; FilterType;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     <a class="code" href="classanima_1_1HierarchicalInitializer.html#af72aabfcd35f6b2c9986c774921b03d1">InputImagePixelType</a> valMaxInput = std::numeric_limits&lt;InputImagePixelType&gt;::max();
<a name="l00218"></a>00218     <a class="code" href="classanima_1_1HierarchicalInitializer.html#af72aabfcd35f6b2c9986c774921b03d1">InputImagePixelType</a> valMinInput = std::numeric_limits&lt;InputImagePixelType&gt;::min();
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="comment">// Compute mean values</span>
<a name="l00221"></a>00221     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> im = 1; im &lt; m_NumberOfModalities; im++ )
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; m_ImagesClasses.size(); c++ )
<a name="l00224"></a>00224         {
<a name="l00225"></a>00225             <span class="comment">//create the histogram with the selected mask</span>
<a name="l00226"></a>00226             <span class="keyword">typename</span> MaskFilterType::Pointer maskFilter = MaskFilterType::New();
<a name="l00227"></a>00227             <span class="keyword">typename</span> MinMaxCalculatorType::Pointer calculator = MinMaxCalculatorType::New();
<a name="l00228"></a>00228             maskFilter-&gt;SetDirectionTolerance(m_Tol);
<a name="l00229"></a>00229             maskFilter-&gt;SetCoordinateTolerance(m_Tol);
<a name="l00230"></a>00230             maskFilter-&gt;SetInput( m_ImagesVector[ im ] );
<a name="l00231"></a>00231             maskFilter-&gt;SetMaskImage( m_ImagesClasses[ c ] );
<a name="l00232"></a>00232 
<a name="l00233"></a>00233             maskFilter-&gt;SetOutsideValue( valMaxInput );
<a name="l00234"></a>00234             maskFilter-&gt;Update();
<a name="l00235"></a>00235             calculator-&gt;SetImage( maskFilter-&gt;GetOutput() );
<a name="l00236"></a>00236             calculator-&gt;ComputeMinimum();
<a name="l00237"></a>00237             <a class="code" href="classanima_1_1HierarchicalInitializer.html#af72aabfcd35f6b2c9986c774921b03d1">InputImagePixelType</a> minimumResult = calculator-&gt;GetMinimum();
<a name="l00238"></a>00238 
<a name="l00239"></a>00239             maskFilter-&gt;SetOutsideValue( valMinInput );
<a name="l00240"></a>00240             maskFilter-&gt;Update();
<a name="l00241"></a>00241             calculator-&gt;SetImage( maskFilter-&gt;GetOutput() );
<a name="l00242"></a>00242             calculator-&gt;ComputeMaximum();
<a name="l00243"></a>00243             <a class="code" href="classanima_1_1HierarchicalInitializer.html#af72aabfcd35f6b2c9986c774921b03d1">InputImagePixelType</a> maximumResult = calculator-&gt;GetMaximum();
<a name="l00244"></a>00244 
<a name="l00245"></a>00245             <span class="keywordtype">double</span> minV = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(minimumResult);
<a name="l00246"></a>00246             <span class="keywordtype">double</span> maxV = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(maximumResult);
<a name="l00247"></a>00247 
<a name="l00248"></a>00248             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bins = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::floor( maxV - minV + 1.0 ));
<a name="l00249"></a>00249 
<a name="l00250"></a>00250             ListSampleType::Pointer listSample = ListSampleType::New();
<a name="l00251"></a>00251             listSample-&gt;SetMeasurementVectorSize( MeasurementVectorLength );
<a name="l00252"></a>00252 
<a name="l00253"></a>00253             <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7cf88b6fbad12599eabf476b7a40512d">InputConstIteratorType</a> tmpIt (m_ImagesVector[im], m_ImagesVector[im]-&gt;GetLargestPossibleRegion() );
<a name="l00254"></a>00254             <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a896bb30424b38c542273f56d66cc49">InputIteratorType</a> classesCIt (m_ImagesClasses[ c ], m_ImagesClasses[ c ]-&gt;GetLargestPossibleRegion() );
<a name="l00255"></a>00255 
<a name="l00256"></a>00256             MeasurementVectorType mv;
<a name="l00257"></a>00257             <span class="keywordflow">while</span> (!classesCIt.IsAtEnd())
<a name="l00258"></a>00258             {
<a name="l00259"></a>00259                 <span class="keywordflow">if</span>(classesCIt.Get()!=0)
<a name="l00260"></a>00260                 {
<a name="l00261"></a>00261                     mv[0] = ( MeasurementType ) tmpIt.Get();
<a name="l00262"></a>00262                     listSample-&gt;PushBack(mv);
<a name="l00263"></a>00263                 }
<a name="l00264"></a>00264                 ++classesCIt;
<a name="l00265"></a>00265                 ++tmpIt;
<a name="l00266"></a>00266             }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268             <span class="comment">// creation histo</span>
<a name="l00269"></a>00269             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numberOfComponents = 1;
<a name="l00270"></a>00270             HistogramType::SizeType size( numberOfComponents );
<a name="l00271"></a>00271             size.Fill( bins );
<a name="l00272"></a>00272             HistogramType::MeasurementVectorType min( numberOfComponents );
<a name="l00273"></a>00273             HistogramType::MeasurementVectorType max( numberOfComponents );
<a name="l00274"></a>00274             min.Fill( minV );
<a name="l00275"></a>00275             max.Fill( maxV );
<a name="l00276"></a>00276 
<a name="l00277"></a>00277             FilterType::Pointer filter = FilterType::New();
<a name="l00278"></a>00278             filter-&gt;SetInput( listSample );
<a name="l00279"></a>00279             filter-&gt;SetHistogramSize( size );
<a name="l00280"></a>00280             filter-&gt;SetHistogramBinMinimum( min );
<a name="l00281"></a>00281             filter-&gt;SetHistogramBinMaximum( max );
<a name="l00282"></a>00282             filter-&gt;Update();
<a name="l00283"></a>00283 
<a name="l00284"></a>00284             HistogramType::ConstPointer histogram = filter-&gt;GetOutput();
<a name="l00285"></a>00285 
<a name="l00286"></a>00286             <span class="keywordtype">double</span> bins2 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(bins) / resolution;
<a name="l00287"></a>00287             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> smoothedBins = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(bins2 + 1);
<a name="l00288"></a>00288 
<a name="l00289"></a>00289             HistogramType::SizeType size2(MeasurementVectorLength);
<a name="l00290"></a>00290             size2.Fill(smoothedBins);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292             HistogramType::MeasurementVectorType lowerBound;
<a name="l00293"></a>00293             lowerBound.SetSize(smoothedBins);
<a name="l00294"></a>00294             lowerBound.Fill(minV);
<a name="l00295"></a>00295 
<a name="l00296"></a>00296             HistogramType::MeasurementVectorType upperBound;
<a name="l00297"></a>00297             upperBound.SetSize(smoothedBins);
<a name="l00298"></a>00298             upperBound.Fill(maxV);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300             HistogramType::Pointer smoothed = HistogramType::New();
<a name="l00301"></a>00301             smoothed-&gt;SetMeasurementVectorSize(MeasurementVectorLength);
<a name="l00302"></a>00302             smoothed-&gt;Initialize(size2, lowerBound, upperBound );
<a name="l00303"></a>00303             smoothed-&gt;SetFrequency(0);
<a name="l00304"></a>00304 
<a name="l00305"></a>00305             std::vector&lt;double&gt; smoothedFrequency(smoothedBins,0);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; bins; ++i)
<a name="l00308"></a>00308             {
<a name="l00309"></a>00309                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; smoothedBins; ++j)
<a name="l00310"></a>00310                 {
<a name="l00311"></a>00311                     <span class="comment">// Calculate distance in intensity values</span>
<a name="l00312"></a>00312                     <span class="keywordtype">double</span> valueI = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i) / static_cast&lt;double&gt;(bins -1) * (maxV - minV) + minV;
<a name="l00313"></a>00313                     <span class="keywordtype">double</span> valueJ = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(j) / static_cast&lt;double&gt;(smoothedBins -1) * (maxV - minV) + minV;
<a name="l00314"></a>00314                     <span class="keywordtype">double</span> kvalue = (valueI - valueJ) / bandwidth;
<a name="l00315"></a>00315                     <span class="keywordtype">double</span> norm = std::exp( -0.5 * kvalue * kvalue ) / std::sqrt( 2.0 * M_PI );
<a name="l00316"></a>00316                     <span class="keywordtype">double</span> value = norm * <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(histogram-&gt;GetFrequency(i));
<a name="l00317"></a>00317                     smoothedFrequency[j] += value;
<a name="l00318"></a>00318                 }
<a name="l00319"></a>00319             }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; smoothedBins; i++ )
<a name="l00322"></a>00322             {
<a name="l00323"></a>00323                 smoothedFrequency[i]/=(<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>( histogram-&gt;GetTotalFrequency()) * bandwidth);
<a name="l00324"></a>00324             }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326             <span class="comment">// get maxs</span>
<a name="l00327"></a>00327             std::vector&lt;unsigned int&gt; maxs;
<a name="l00328"></a>00328             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localMax = 3;
<a name="l00329"></a>00329             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; smoothedBins; i++ )
<a name="l00330"></a>00330             {
<a name="l00331"></a>00331         <span class="keywordtype">int</span> testVal = i - localMax;
<a name="l00332"></a>00332                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jmin = testVal &lt; 0 ? 0 : testVal;  
<a name="l00333"></a>00333 
<a name="l00334"></a>00334                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> jmax = ( i + localMax ) &gt; smoothedBins ? smoothedBins : ( i + localMax );
<a name="l00335"></a>00335 
<a name="l00336"></a>00336                 <span class="keywordtype">bool</span> ismax = <span class="keyword">true</span>;
<a name="l00337"></a>00337                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = jmin; j &lt; jmax; j++ )
<a name="l00338"></a>00338                 {
<a name="l00339"></a>00339                     <span class="keywordflow">if</span> ( (i != j) &amp;&amp; (smoothedFrequency[i] &lt;= smoothedFrequency[j]) )
<a name="l00340"></a>00340                     {
<a name="l00341"></a>00341                         ismax = <span class="keyword">false</span>;
<a name="l00342"></a>00342                         <span class="keywordflow">continue</span>;
<a name="l00343"></a>00343                     }
<a name="l00344"></a>00344                 }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346                 <span class="keywordflow">if</span> ( ismax &amp;&amp; ( smoothedFrequency[i] &gt; 0.001 ) )
<a name="l00347"></a>00347                 {
<a name="l00348"></a>00348                     maxs.push_back( i );
<a name="l00349"></a>00349                 }
<a name="l00350"></a>00350             }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352             <span class="keywordflow">if</span>(maxs.size()==0)
<a name="l00353"></a>00353             {
<a name="l00354"></a>00354                 std::cerr &lt;&lt; <span class="stringliteral">&quot;--Error in Hierarchical Initializer: no maximum value&quot;</span> &lt;&lt; std::endl;
<a name="l00355"></a>00355                 exit(-1);
<a name="l00356"></a>00356             }
<a name="l00357"></a>00357             <span class="keywordflow">else</span>
<a name="l00358"></a>00358             {
<a name="l00359"></a>00359                 <span class="comment">// Keeping only the good max according to the rules</span>
<a name="l00360"></a>00360                 <span class="keywordtype">double</span> value = 0;
<a name="l00361"></a>00361                 <span class="keywordflow">switch</span> ( selectionRules[ im ][ c ] )
<a name="l00362"></a>00362                 {
<a name="l00363"></a>00363                 <span class="keywordflow">case</span> - 1: <span class="comment">// darker max</span>
<a name="l00364"></a>00364                 {
<a name="l00365"></a>00365                     value = ( <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(maxs[0]) / static_cast&lt;double&gt;(bins-1) ) * (maxV - minV) + minV;
<a name="l00366"></a>00366                     m_SelectedMax[im][c] = value;
<a name="l00367"></a>00367                     <span class="keywordflow">break</span>;
<a name="l00368"></a>00368                 }
<a name="l00369"></a>00369                 <span class="keywordflow">case</span> 1: <span class="comment">// brigther max</span>
<a name="l00370"></a>00370                 {
<a name="l00371"></a>00371                     value = ( <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(maxs[ maxs.size() - 1 ]) / static_cast&lt;double&gt;(bins-1) ) * (maxV - minV) + minV;
<a name="l00372"></a>00372                     m_SelectedMax[ im ][ c ] = value;
<a name="l00373"></a>00373                     <span class="keywordflow">break</span>;
<a name="l00374"></a>00374                 }
<a name="l00375"></a>00375                 <span class="keywordflow">case</span> 0: <span class="comment">// absolute max</span>
<a name="l00376"></a>00376                 <span class="keywordflow">default</span>:
<a name="l00377"></a>00377                 {
<a name="l00378"></a>00378                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> absMaxIndex = 0;
<a name="l00379"></a>00379                     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> absMaxValue = 0;
<a name="l00380"></a>00380                     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; maxs.size(); i++ )
<a name="l00381"></a>00381                     {
<a name="l00382"></a>00382                         <span class="keywordflow">if</span> ( maxs[ i ] &gt; absMaxValue )
<a name="l00383"></a>00383                         {
<a name="l00384"></a>00384                             absMaxValue = maxs[ i ];
<a name="l00385"></a>00385                             absMaxIndex = i;
<a name="l00386"></a>00386                         }
<a name="l00387"></a>00387                     }
<a name="l00388"></a>00388                     value = ( <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(maxs[ absMaxIndex ]) / static_cast&lt;double&gt;(bins-1) ) * (maxV - minV) + minV;
<a name="l00389"></a>00389                     m_SelectedMax[ im ][ c ] = value;
<a name="l00390"></a>00390                     <span class="keywordflow">break</span>;
<a name="l00391"></a>00391                 }
<a name="l00392"></a>00392                 }
<a name="l00393"></a>00393             }
<a name="l00394"></a>00394         }
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396 }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00399"></a>00399 <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#af3bf1b13638346505a44ecd6c321fcd2">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00400"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#af3bf1b13638346505a44ecd6c321fcd2">00400</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#af3bf1b13638346505a44ecd6c321fcd2">::ComputeVariances</a>()
<a name="l00401"></a>00401 {
<a name="l00402"></a>00402     ImageTypeD::Pointer diff = ImageTypeD::New();
<a name="l00403"></a>00403     diff-&gt;SetRegions(this-&gt;GetMask()-&gt;GetLargestPossibleRegion());
<a name="l00404"></a>00404     diff-&gt;CopyInformation(this-&gt;GetMask());
<a name="l00405"></a>00405     diff-&gt;Allocate();
<a name="l00406"></a>00406     diff-&gt;FillBuffer(0);
<a name="l00407"></a>00407     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a0b1c98396b6e33d6a4787a05145a220c">ImageIteratorTypeD</a> diffIt(diff, diff-&gt;GetLargestPossibleRegion() );
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     std::vector&lt;InputIteratorType&gt; classesItVec;
<a name="l00410"></a>00410     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_ImagesClasses.size(); i++)
<a name="l00411"></a>00411     {
<a name="l00412"></a>00412         <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a896bb30424b38c542273f56d66cc49">InputIteratorType</a> classesIt (m_ImagesClasses[i],m_ImagesClasses[i]-&gt;GetLargestPossibleRegion() );
<a name="l00413"></a>00413         classesItVec.push_back(classesIt);
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416     std::vector&lt;InputConstIteratorType&gt; imagesVectorItVec;
<a name="l00417"></a>00417     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfModalities; i++)
<a name="l00418"></a>00418     {
<a name="l00419"></a>00419         <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7cf88b6fbad12599eabf476b7a40512d">InputConstIteratorType</a> imagesVectorIt (m_ImagesVector[i], m_ImagesVector[i]-&gt;GetLargestPossibleRegion() );
<a name="l00420"></a>00420         imagesVectorItVec.push_back(imagesVectorIt);
<a name="l00421"></a>00421     }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     <span class="keyword">const</span> <span class="keywordtype">float</span> estimatorFactor = 1.4918; <span class="comment">// factor to compute standard deviation using a robust variance estimator</span>
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> im = 1; im &lt; m_NumberOfModalities; im++ )
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427         <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; m_ImagesClasses.size(); c++ )
<a name="l00428"></a>00428         {
<a name="l00429"></a>00429 
<a name="l00430"></a>00430             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_ImagesClasses.size(); i++)
<a name="l00431"></a>00431             {
<a name="l00432"></a>00432                 classesItVec[i].GoToBegin();
<a name="l00433"></a>00433             }
<a name="l00434"></a>00434             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfModalities; i++)
<a name="l00435"></a>00435             {
<a name="l00436"></a>00436                 imagesVectorItVec[i].GoToBegin();
<a name="l00437"></a>00437             }
<a name="l00438"></a>00438             diffIt.GoToBegin();
<a name="l00439"></a>00439 
<a name="l00440"></a>00440             <span class="keywordflow">while</span> (!diffIt.IsAtEnd())
<a name="l00441"></a>00441             {
<a name="l00442"></a>00442 
<a name="l00443"></a>00443                 <span class="keywordflow">if</span>(classesItVec[c].Get() &gt; 0)
<a name="l00444"></a>00444                 {
<a name="l00445"></a>00445                     diffIt.Set(std::fabs(imagesVectorItVec[im].Get()-m_SelectedMax[im][c]));
<a name="l00446"></a>00446                 }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_ImagesClasses.size(); i++)
<a name="l00449"></a>00449                 {
<a name="l00450"></a>00450                     ++classesItVec[i];
<a name="l00451"></a>00451                 }
<a name="l00452"></a>00452                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_NumberOfModalities; i++)
<a name="l00453"></a>00453                 {
<a name="l00454"></a>00454                     ++imagesVectorItVec[i];
<a name="l00455"></a>00455                 }
<a name="l00456"></a>00456                 ++diffIt;
<a name="l00457"></a>00457             }
<a name="l00458"></a>00458             m_Stds[im][c] = estimatorFactor * regionMedianValue(diff,m_ImagesClasses[c]);
<a name="l00459"></a>00459         }
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00464"></a>00464 <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a42d798cc03d5607ce02e08dfafc2be3b">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00465"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a42d798cc03d5607ce02e08dfafc2be3b">00465</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a42d798cc03d5607ce02e08dfafc2be3b">::FillInitialGaussianModel</a>()
<a name="l00466"></a>00466 {
<a name="l00467"></a>00467     m_GaussianModel.clear();
<a name="l00468"></a>00468     m_Alphas.clear();
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_NbClasses; i++ )
<a name="l00471"></a>00471     {
<a name="l00472"></a>00472         GaussianFunctionType::Pointer densityFunction1 = GaussianFunctionType::New();
<a name="l00473"></a>00473         densityFunction1-&gt;SetMeasurementVectorSize( m_NbClasses );
<a name="l00474"></a>00474         GaussianFunctionType::MeanVectorType mean1( m_NbClasses );
<a name="l00475"></a>00475         GaussianFunctionType::CovarianceMatrixType cov1;
<a name="l00476"></a>00476         cov1.SetSize( m_NbClasses, m_NbClasses );
<a name="l00477"></a>00477         cov1.Fill(0);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479         <span class="comment">// Take information from T1-w</span>
<a name="l00480"></a>00480         GaussianFunctionType::MeanVectorType t1mean = (m_Solution1D[i])-&gt;GetMean();
<a name="l00481"></a>00481         GaussianFunctionType::CovarianceMatrixType t1var = (m_Solution1D[i])-&gt;GetCovariance();
<a name="l00482"></a>00482 
<a name="l00483"></a>00483         mean1[0] = t1mean[0];
<a name="l00484"></a>00484         mean1[1] = m_SelectedMax[1][i];
<a name="l00485"></a>00485         mean1[2] = m_SelectedMax[2][i];
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         cov1[0][0] = t1var[0][0];
<a name="l00488"></a>00488         cov1[1][1] = m_Stds[1][i]*m_Stds[1][i];
<a name="l00489"></a>00489         cov1[2][2] = m_Stds[2][i]*m_Stds[2][i];
<a name="l00490"></a>00490 
<a name="l00491"></a>00491         densityFunction1-&gt;SetMean( mean1 );
<a name="l00492"></a>00492         densityFunction1-&gt;SetCovariance( cov1 );
<a name="l00493"></a>00493 
<a name="l00494"></a>00494         m_GaussianModel.push_back(densityFunction1);
<a name="l00495"></a>00495         m_Alphas.push_back(m_Solution1DAlphas[i]);
<a name="l00496"></a>00496     }
<a name="l00497"></a>00497 }
<a name="l00498"></a>00498 
<a name="l00499"></a>00499 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00500"></a>00500 <span class="keywordtype">double</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a2b1f6f1eaa479742c7f4acb241aa6197">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;</a>
<a name="l00501"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#a2b1f6f1eaa479742c7f4acb241aa6197">00501</a> <a class="code" href="classanima_1_1HierarchicalInitializer.html#a2b1f6f1eaa479742c7f4acb241aa6197">::regionMedianValue</a>(itk::Image&lt; double, 3 &gt;::Pointer image, <span class="keyword">typename</span> TInputImage::Pointer mask )
<a name="l00502"></a>00502 {
<a name="l00503"></a>00503     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a0b1c98396b6e33d6a4787a05145a220c">ImageIteratorTypeD</a> imageIt(image, image-&gt;GetLargestPossibleRegion() );
<a name="l00504"></a>00504     <a class="code" href="classanima_1_1HierarchicalInitializer.html#a7a896bb30424b38c542273f56d66cc49">InputIteratorType</a> maskIt(mask, mask-&gt;GetLargestPossibleRegion() );
<a name="l00505"></a>00505 
<a name="l00506"></a>00506     std::vector&lt;double&gt; regionValueVector;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508     <span class="keywordflow">while</span>(!imageIt.IsAtEnd())
<a name="l00509"></a>00509     {
<a name="l00510"></a>00510         <span class="keywordflow">if</span> ( maskIt.Get() != 0 )
<a name="l00511"></a>00511         {
<a name="l00512"></a>00512             regionValueVector.push_back(imageIt.Get());
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514         ++imageIt;
<a name="l00515"></a>00515         ++maskIt;
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517     std::sort (regionValueVector.begin(), regionValueVector.end());
<a name="l00518"></a>00518     <span class="keywordflow">return</span> regionValueVector[regionValueVector.size()/2];
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TInputImage, <span class="keyword">typename</span> TMaskImage&gt;
<a name="l00522"></a><a class="code" href="classanima_1_1HierarchicalInitializer.html#aaa82f07f1c4dfa7845f94c3a8797e5dc">00522</a> <span class="keywordtype">void</span> <a class="code" href="classanima_1_1HierarchicalInitializer.html#aaa82f07f1c4dfa7845f94c3a8797e5dc">HierarchicalInitializer&lt;TInputImage,TMaskImage&gt;::Update</a>()
<a name="l00523"></a>00523 {
<a name="l00524"></a>00524     m_ImagesVector.clear();
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     <span class="keywordflow">if</span>(m_IndexImage1&lt;m_NbMaxImages){m_ImagesVector.push_back(this-&gt;GetInputImage1());}
<a name="l00527"></a>00527     <span class="keywordflow">if</span>(m_IndexImage2&lt;m_NbMaxImages){m_ImagesVector.push_back(this-&gt;GetInputImage2());}
<a name="l00528"></a>00528     <span class="keywordflow">if</span>(m_IndexImage3&lt;m_NbMaxImages){m_ImagesVector.push_back(this-&gt;GetInputImage3());}
<a name="l00529"></a>00529     <span class="keywordflow">if</span>(m_IndexImage4&lt;m_NbMaxImages){m_ImagesVector.push_back(this-&gt;GetInputImage4());}
<a name="l00530"></a>00530     <span class="keywordflow">if</span>(m_IndexImage5&lt;m_NbMaxImages){m_ImagesVector.push_back(this-&gt;GetInputImage5());}
<a name="l00531"></a>00531 
<a name="l00532"></a>00532     m_NumberOfModalities = m_ImagesVector.size();
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     this-&gt;ComputeSolution1D();
<a name="l00535"></a>00535     this-&gt;ComputeInitialT1Classification();
<a name="l00536"></a>00536     this-&gt;ComputeHistogram();
<a name="l00537"></a>00537     this-&gt;ComputeVariances();
<a name="l00538"></a>00538     this-&gt;FillInitialGaussianModel();
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 } <span class="comment">// end of namespace</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!-- start footer part -->


<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 7 2017 14:33:06 for ANIMA by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-36582801-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>
